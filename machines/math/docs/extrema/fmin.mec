math/fmin
===============================================================================

%% Elementwise minimum, IEEE-754 minimumNumber semantics

1. Usage
-------------------------------------------------------------------------------

```mech:disabled
Z := math/fmin(X, Y)
```

2. Description
-------------------------------------------------------------------------------

Returns the elementwise minimum of `X` and `Y`. The result `Z` has the same
shape as the inputs. This function follows IEEE-754 *minimumNumber* semantics:
if exactly one argument is `NaN`, the other argument is returned; if both are
`NaN`, the result is `NaN`.

3. Input
-------------------------------------------------------------------------------

| Argument | Kind                               | Description |
|----------|------------------------------------|-------------|
| `X`      | `float`, `[float]`, `matrix`       | First input. Accepts real numeric types supported by the runtime; common cases are `f64`, `f32`, and their vector/matrix forms. |
| `Y`      | `float`, `[float]`, `matrix`       | Second input. Must match the shape and type of `X`. |

4. Output
-------------------------------------------------------------------------------

| Argument | Kind             | Description |
|----------|------------------|-------------|
| `Z`      | matches input    | Elementwise minimum of `X` and `Y`. Shape and type match `X`/`Y`. |

5. Examples  
-------------------------------------------------------------------------------

(a) Minimum of two numbers

```mech:ex1
z := math/fmin(2.5, 7.0)           
```

(b) Elementwise minimum for vectors

```mech:ex2
x := [1.0, 5.0, -3.0]
y := [4.0, 2.0, -7.0]
z := math/fmin(x, y)               
```

(c) Elementwise minimum for a matrix

```mech:ex3
a := [1.0, -2.0; 3.5, 0.0]
b := [0.5, -3.0; 2.0, 4.0]
z := math/fmin(a, b)               
```

6. Details
-------------------------------------------------------------------------------

- **Semantics:** Uses IEEE-754 *minimumNumber*. Unlike a NaN-propagating min,
  this treats `NaN` specially: if exactly one operand is `NaN`, the other is
  chosen if both are `NaN`, the result is `NaN`. This avoids `NaN` contagion
  when only one side is invalid.

- **Shapes:** `X` and `Y` must have identical shapes. Scalars with scalars,
  vectors with vectors, and matrices with matrices (same dimensions). The
  result `Z` matches the input shape.

- **Types:** Backed by platform implementations of `fmin` (f64) and `fminf`
  (f32). Vector and matrix forms apply the same operation elementwise.
  Mixed-precision inputs are not allowed; cast beforehand if needed.

- **Signed zeros & ties:** Per IEEE-754 and typical libm behavior,
  `math/fmin(+0.0, -0.0)` yields `-0.0`. If values compare equal, the chosen
  operand follows IEEE rules and underlying implementation details.

- **Performance:** Vector and matrix forms loop over elements in place. For
  large arrays, prefer matching contiguous memory layouts to maximize locality.

7. Notes for Implementers
-------------------------------------------------------------------------------

This operation corresponds to the Rust/libm functions `fmin` (f64) and `fminf`
(f32). In this codebase, dispatch is generated across scalar, vector, and matrix
types each variant performs the same elementwise minimum and returns an output
of the same shape and type.

