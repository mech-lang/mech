Introduction
==============================================================================

1. Welcome to Mech!
------------------------------------------------------------------------------

Hello and welcome to the documentation for Mech, a programming language and platform for developing data-driven, reactive systems. Mech authors build programs by defining data dependencies, transformations, and state machines. This makes Mech particularly well-suited for applications that require real-time data processing, such as simulations, visualizations, and cyber-physical systems like robots.

(1.1) An Example Program

Here's some Mech code for a familiar program, FizzBuzz:

```mech:FizzBuzz
  x := 1..=10               -- A row vector of numbers from {1} to {10}
  ~out<[string]> := x       -- Convert `x` into mutable string vec
  
  ix2 := (x % 2) == 0       -- Indices for multiples of {2}
  ix3 := (x % 3) == 0       -- Indices for multiples of {3}
  
  out[ix2] = "‚ú®"           -- Set multiples of {2} to {"‚ú®"}
  out[ix3] = "üêù"           -- Set multiples of {3} to {"üêù"}
  out[ix2 && ix3] = "‚ú®üêù"  -- Set multiples of both to {"‚ú®üêù"}
```

This short example demonstrates several key features of the language:

- **Concise syntax**: Expressive and flexible, with no need for keywords or semicolons; Mech programs are generally shorter than in other languages.
- **Broadcast operations**: Vector operations apply elementwise automatically, removing loops and enabling efficient vectorization.
- **Type inference**: Variable and expression types are inferred, so explicit type declarations are often unnecessary.
- **Immutable by default**: Variables are immutable unless specified, promoting safer code and easier reasoning.
- **Logical indexing**: Select and manipulate vector elements via conditions, enabling declarative iteration and parallel execution.
- **Rich text formatting**: Comments and code support rich formatting, making documentation clear and readable.

(i)> For a complete list of planned features, see the [ROADMAP](/design/ROADMAP.html).

(1.2) The Need



(1.3) Mech Puts Data First

More than anything, computing today is about data. Programs ingest, transform, and output data. They respond to changes in data from users, sensors, and networks. They process large datasets to extract insights and make decisions. AI systems especially rely on data, for training, inference, and context.

Yet most programming languages are designed around the idea of sequences of instructions that manipulate memory locations -- the data is not represented and manipulated directly, but rather idirectly through these instructions. Data is hidden in registers and not viewable or queryable by the programmer. This makes it difficult to reason about how data flows through a program, and how changes in data affect the program's behavior. And when it comes time to debug, optimize, or extend the program, this indirect representation of data becomes a major obstacle.

In Mech, you start by defining data and transformations on them. The Mech compiler and runtime automatically determine how data flows through your program, and optimizes it for performance. When underlying data change, Mech updates all dependent data automatically. This makes it easier to build systems that react to change, without having to write custom event loops or bring in large frameworks.

(1.4) Use Cases

Mech is designed to make building data-driven systems easier by providing a reactive programming model based on defining data dependencies and transformations. Mech also provides a new AI-first programming model that allows users to write Mech programs without even knowing the language -- an idea that is very hard to implement on top of languages not designed for this new frontier.

Mech programs can be thought of as feedback control systems, where data flows through a network of transformations and state machines that react to changes in the data. This covers a lot of common use cases:

- Games - receives user input from a game controller, updates internal player scores and runs game logic, then renders the game to the screen.
- Embedded Systems - sensors make environmental readings and update the device, which reacts by controlling actuators or sending messages.
- User Interfaces - the user clicks a button or types on their keyboard, which changes the UI state, which is then rendered to the screen.
- Data Science - the user loads data from a source and processes it, which updates visualizations or statistical models.  
- Robotics - sensor readings from cameras and LIDAR are processed by the robot to update its internal belief, which is used to plan and execute actions in the physical world.
- Web Applications - user interactions and network events update the application state, which is then rendered to the DOM (Document Object Model) for display in the browser.

If you are building one of these types of systems, Mech may be a good fit for your project!

3. Programming System
-------------------------------------------------------------------------------

Mech comes with integrated tools for data transformation, distribution, resource monitoring, and program optimization. We call this the "Platform", which is distinct from the "Language", which is the syntax and semantics used to write Mech programs.

In Mech, programmers define data and their relationships. Then they transformation these data with a rich set of operators and functions. Mech's compiler and runtime automatically determine how data flows through programs, and optimizes them for performance. When underlying data change, Mech updates all dependent data automatically. The Mech Platform also serializes, distributes, and logs your data. Together, this allows you to build efficient, data-driven, distributed systems that react to change, without having to write custom event loops or bring in large frameworks.

(3.1) Overview

The Mech programming platform consists of four parts:

1. **A data description language**, which allows you to define the structure of your data and how it can be transformed.
2. **A reactive programming model**, based on state machines, which allows you to write systems that can take advantage of asynchrouns and parallel program execution. `WIP`
3. **A distributed execution engine**, which allows you to run Mech programs across multiple machines in a variety of environments. `WIP`
4. **A rich set of "machines"**, libraries, tools, and data sources which provide a wide range of functionality. `WIP`

(3.2) Tools

- `mech` - the Mech programming language toolchain, which includes:
    - Parser and compiler for the text-based Mech syntax
    - Runtime for executing Mech programs
    - REPL for interactive programming
    - Formatter for formatting Mech code into canonical style or HTML documentation.
    - Server for serving Mech programs to a wasm client
    - Language Server Protocol implementation
- `mech-wasm` - a wasm-based client for running Mech programs in the browser or other wasm environments.
- `mech-notebook` - a notebook editor for Mech that runs natively on Windows, macOS, and Linux, and also supports running in the browser via `mech-wasm`.

(3.3) Features

Some of the key features of the Mech programming platform include:

- **Automatic data propagation**: Mech automatically tracks data dependencies and propagates changes through the program, ensuring that all dependent data are updated correctly.
- **Vectorized operations**: Mech supports vectorized operations, allowing you to perform computations on entire arrays of data without explicit loops, which leads to more concise and efficient code.
- **Live, literate programming**: Mech supports live literate programming environment, meaning you can write and execute code in an interactive notebook-style interface, with rich text formatting and inline documentation.
- **Distribution and serialization**: Mech programs can be easily distributed across multiple machines, and all data can be serialized and deserialized automatically, including entire functions and programs.
- **Time travel debugging**: Mech's runtime supports time travel debugging, allowing you to step forwards and backwards through program execution to inspect the state of your data at any point in time.
- **AI-optimized**: Mech is designed to be particularly amenable to the architectures and techniques used in artificial intelligence systems, making it easier for AI to understand and write Mech code even without having been trained on it.

For a complete list of features and the statuses of their implementations, see the [ROADMAP](https://docs.mech-lang.org/design/ROADMAP.html).

4. About this Documentation
-------------------------------------------------------------------------------

This documentation is designed to help you get started with Mech, understand its core concepts, and provide guidance on how to use the language effectively. It is structured as follows:

1. **Getting Started**: an introduction to Mech, how to install it, and how to build and run Mech programs. It also covers the Mech REPL (Read-Eval-Print Loop) for interactive programming.
2. **Reference**: a detailed reference for the Mech language, including its data model, programming model, system model, standard library, and Mechdown reference.
3. **Guides**: provides practical guides and tutorials for using Mech, including a quick introduction to the language, tutorials for specific use cases, and guides for developers coming from other programming languages.
4. **Design Documents**: information on the design principles behind Mech, including the language specification, design principles, syntax design notes, and the roadmap for future development, as well as the history of the language.

(i)> This documentation is written in Mechdown, a lightweight markup language that is designed simulatneously with Mech. This means that each document is a valid program that can be executed on the Mech platform.

5. Getting Involved
-------------------------------------------------------------------------------

The Mech community stays active at a few places around the Internet:

- [Discord](https://discord.gg/asqP25NNTH) - for live chat
- [GitHub](https://github.com/mech-lang) - for code and issues
- [YouTube](https://www.youtube.com/@MechLang) - for video tutorials
- [Reddit](https://www.reddit.com/r/mechlang/) - for help and general discussion
- [Mailing List](https://groups.google.com/g/mechtalk) - for dev discussion

6. Project Status
-------------------------------------------------------------------------------

Mech has been in [active development since 2018](https://github.com/mech-lang/mech/graphs/contributors), and reached beta status in 2022.

The beta phase has focused on stabilizing the core language and fixing shortcomings of the initial design. We anticipate four stages of development in the beta stage:

-(‚òëÔ∏è) [v0.1](https://github.com/mech-lang/mech/tree/v0.1-beta) - proof of concept system - minimum viable language implementation
-(üìç) [v0.2](https://github.com/mech-lang/mech/tree/v0.2-beta) - data specification - formulas, defining and manipulating data
-(‚òê) v0.3 - program specification - functions, modules, state machines
-(‚òê) v0.4 - system specification - tools, distributed programs, capabilities

Currently the platform version is `v0.2.70-beta`.

Visit the [ROADMAP](https://docs.mech-lang.org/design/ROADMAP.html) for more information on the current status of features.

***

[^1]: Papert was a pioneer in the field of educational computing, and is best known for his work on the Logo programming language and his advocacy for constructivist learning theories.

[^2]: Some believe that AI will completely supplant programming languages; instead of writing code and compiling to machine code, LLMs will either directly write machinecode, or even act as a runtime environment and execute the program itself. We do not believe this will happen, at least in the nearterm. See our post ["LLMs Will Not Replace Programming Languages"](https://mech-lang.org/post/2025-01-09-programming-chatgpt/) for more on our reasoning, but the short version is that programming languages provide a level of abstraction and structure that is necessary for building complex systems, and that AI systems will need to work within these abstractions to be effective.