Introduction
==============================================================================

1. Welcome to Mech!
------------------------------------------------------------------------------

Hello and welcome to the documentation for Mech, a programming language and platform for developing data-driven, reactive systems. Mech authors build programs by defining data dependencies, transformations, and state machines. This makes Mech particularly well-suited for applications that require real-time data processing, such as simulations, visualizations, and cyber-physical systems like robots.

(1.1) An Example: FizzBuzz

Here's Mech some code:

```mech
  x := 1..=10               -- A row vector of numbers from {1} to {10}
  ~out<[string]> := x       -- Convert `x` into mutable string vec
  
  ix2 := (x % 2) == 0       -- Indices for multiples of {2}
  ix3 := (x % 3) == 0       -- Indices for multiples of {3}
  
  out[ix2] = "‚ú®"           -- Set multiples of {2} to {"‚ú®"}
  out[ix3] = "üêù"           -- Set multiples of {3} to {"üêù"}
  out[ix2 && ix3] = "‚ú®üêù"  -- Set multiples of both to {"‚ú®üêù"}
```

This short example demonstrates several key features of the language:

- **Concise syntax**: Expressive and flexible, with no need for keywords or semicolons; Mech programs are generally shorter than in other languages.
- **Broadcast operations**: Vector operations apply elementwise automatically, removing loops and enabling efficient vectorization.
- **Type inference**: Variable and expression types are inferred, so explicit type declarations are often unnecessary.
- **Immutable by default**: Variables are immutable unless specified, promoting safer code and easier reasoning.
- **Logical indexing**: Select and manipulate vector elements via conditions, enabling declarative iteration and parallel execution.
- **Rich text formatting**: Comments and code support rich formatting, making documentation clear and readable.

For a complete list of planned features and their implementation statuses, see the [ROADMAP](https://docs.mech-lang.org/design/ROADMAP.html).

(1.2) The Vision and Need

Most popular languages today were conceived at a time before the rise of the Internet, smartphones, cloud computing, and now robotics and artificial intelligence. They've managed to stay relevant by continually adapting to new paradigms and use cases, which takes the form of adding new language features, libraries, frameworks, and middleware on top of the core language. But this comes at a cost of increased complexity, both in terms of the language itself and the ecosystem surrounding it, which makes it harder to learn and use them correctly.

But what if we approached it from the opposite direction? Instead of starting from a language of the past and layering on compatibility for the present, what if we start in the context of the present and work backwards to design a language that fits the needs of today best, without worrying about baggage from the past? Could such a language be simpler, more powerful, more expressive, and easier to use? Would the design turn out substantively different from the languages we are currently retrofitting for the present? Would it allow programmers to build more reliable, more performant, and easier-to-maintain systems?

These are the foundational questions the Mech project aims to answer. We are combing through 70 years of programming language history, taking the most promising ideas -- some of which have achieved mainstream success, many of which have only begun to be explored -- and reimagining them for the modern era. The result is a language and platform designed from the ground up to seriously tackle the incidental complexity that has accrued in software development over the past several decades.

That's a tall order, but we believe it's necessary to build the next generation of software systems capable of meeting the demands of the future. These systems will need to be more adaptive, more resilient, and more capable of handling the complexities of the real world. They will be driven by streams of data from a variety of sources, processed in real time, executed on heterogeneous hardware and software platforms, and deployed over networks distributed all over the world. Not only that, the actual software will not be written by humans, but generated and optimized by artificial intelligence systems. And it won't be executed on a machine tied to a desk, but on a robot that can move in the world and has agency. 

We call these "data-driven, reactive systems", and Mech is designed to be *the* language and platform for building them.

(1.3) Why Mech?

Mech is designed to make building data-driven systems easier by providing a reactive programming model based on defining data dependencies and transformations. Mech also provides a new AI-first programming model that allows users to write Mech programs without even knowing the language -- an idea that is very hard to implement on top of languages not designed for this new frontier.

Mech programs can be thought of as feedback control systems, where data flows through a network of transformations and state machines that react to changes in the data. This covers a lot of common use cases:

- Games - receives user input from a game controller, updates internal player scores and runs game logic, then renders the game to the screen.
- Embedded Systems - sensors make environmental readings and update the device, which reacts by controlling actuators or sending messages.
- User Interfaces - the user clicks a button or types on their keyboard, which changes the UI state, which is then rendered to the screen.
- Data Science - the user loads data from a source and processes it, which updates visualizations or statistical models.  
- Robotics - sensor readings from cameras and LIDAR are processed by the robot to update its internal belief, which is used to plan and execute actions in the physical world.
- Web Applications - user interactions and network events update the application state, which is then rendered to the DOM (Document Object Model) for display in the browser.

If you are building one of these types of systems, Mech may be a good fit for your project!

3. Programming System
-------------------------------------------------------------------------------

Mech comes with integrated tools for data transformation, distribution, resource monitoring, and program optimization. We call this the "Platform", which is distinct from the "Language", which is the syntax and semantics used to write Mech programs.

In Mech, programmers define data and their relationships. Then they transformation these data with a rich set of operators and functions. Mech's compiler and runtime automatically determine how data flows through programs, and optimizes them for performance. When underlying data change, Mech updates all dependent data automatically. The Mech Platform also serializes, distributes, and logs your data. Together, this allows you to build efficient, data-driven, distributed systems that react to change, without having to write custom event loops or bring in large frameworks.

(3.1) Overview

The Mech programming platform consists of four parts:

1. **A data description language**, which allows you to define the structure of your data and how it can be transformed.
2. **A reactive programming model**, based on state machines, which allows you to write systems that can take advantage of asynchrouns and parallel program execution. `WIP`
3. **A distributed execution engine**, which allows you to run Mech programs across multiple machines in a variety of environments. `WIP`
4. **A rich set of "machines"**, libraries, tools, and data sources which provide a wide range of functionality. `WIP`

(3.2) Tools

- `mech` - the Mech programming language toolchain, which includes:
    - Parser and compiler for the text-based Mech syntax
    - Runtime for executing Mech programs
    - REPL for interactive programming
    - Formatter for formatting Mech code into canonical style or HTML documentation.
    - Server for serving Mech programs to a wasm client
    - Language Server Protocol implementation
- `mech-wasm` - a wasm-based client for running Mech programs in the browser or other wasm environments.
- `mech-notebook` - a notebook editor for Mech that runs natively on Windows, macOS, and Linux, and also supports running in the browser via `mech-wasm`.

(3.3) Features

Some of the key features of the Mech programming platform include:

- **Automatic data propagation**: Mech automatically tracks data dependencies and propagates changes through the program, ensuring that all dependent data are updated correctly.
- **Vectorized operations**: Mech supports vectorized operations, allowing you to perform computations on entire arrays of data without explicit loops, which leads to more concise and efficient code.
- **Live, literate programming**: Mech supports live literate programming environment, meaning you can write and execute code in an interactive notebook-style interface, with rich text formatting and inline documentation.
- **Distribution and serialization**: Mech programs can be easily distributed across multiple machines, and all data can be serialized and deserialized automatically, including entire functions and programs.
- **Time travel debugging**: Mech's runtime supports time travel debugging, allowing you to step forwards and backwards through program execution to inspect the state of your data at any point in time.
- **AI-optimized**: Mech is designed to be particularly amenable to the architectures and techniques used in artificial intelligence systems, making it easier for AI to understand and write Mech code even without having been trained on it.

For a complete list of features and the statuses of their implementations, see the [ROADMAP](https://docs.mech-lang.org/design/ROADMAP.html).

4. About this Documentation
-------------------------------------------------------------------------------

This documentation is designed to help you get started with Mech, understand its core concepts, and provide guidance on how to use the language effectively. It is structured as follows:

1. **Getting Started**: an introduction to Mech, how to install it, and how to build and run Mech programs. It also covers the Mech REPL (Read-Eval-Print Loop) for interactive programming.
2. **Reference**: a detailed reference for the Mech language, including its data model, programming model, system model, standard library, and Mechdown reference.
3. **Guides**: provides practical guides and tutorials for using Mech, including a quick introduction to the language, tutorials for specific use cases, and guides for developers coming from other programming languages.
4. **Design Documents**: information on the design principles behind Mech, including the language specification, design principles, syntax design notes, and the roadmap for future development, as well as the history of the language.

(i)> This documentation is written in Mechdown, a lightweight markup language that is designed simulatneously with Mech. This means that each document is a valid program that can be executed on the Mech platform.

5. Getting Involved
-------------------------------------------------------------------------------

The Mech community stays active at a few places around the Internet:

-(üëæ) [Discord](https://discord.gg/asqP25NNTH) - for live chat
-(üêô) [GitHub](https://github.com/mech-lang) - for code and issues
-(üì∫) [YouTube](https://www.youtube.com/@MechLang) - for video tutorials
-(üõ∏) [Reddit](https://www.reddit.com/r/mechlang/) - for help and general discussion
-(üìß) [Mailing List](https://groups.google.com/g/mechtalk) - for dev discussion

6. Project Status
-------------------------------------------------------------------------------

Mech has been in [active development since 2018](https://github.com/mech-lang/mech/graphs/contributors), and reached beta status in 2022.

The beta phase has focused on stabilizing the core language and fixing shortcomings of the initial design. We anticipate four stages of development in the beta stage:

-(‚òëÔ∏è) [v0.1](https://github.com/mech-lang/mech/tree/v0.1-beta) - proof of concept system - minimum viable language implementation
-(üìç) [v0.2](https://github.com/mech-lang/mech/tree/v0.2-beta) - data specification - formulas, defining and manipulating data
-(‚òê) v0.3 - program specification - functions, modules, state machines
-(‚òê) v0.4 - system specification - tools, distributed programs, capabilities

Currently the platform version is `v0.2.68-beta`.

Visit the [ROADMAP](https://docs.mech-lang.org/design/ROADMAP.html) for more information on the current status of features.