In 2007, DARPA[^1] hosted a "Grand Urban Challenge" in which researchers were tasked with building autonomous vehicles that could navigate a city environment. The competition was structured in two phases: first, a qualifying round where teams had to demonstrate their vehicles could navigate a simple course, and then a final round where they had to navigate a more complex urban environment. 

```diagram
---
config:
  sankey:
    height: 175
---
sankey-beta

%% source,target,value
Site Visit,Semifinalists,35
Site Visit,Did Not Qualify,18
Semifinalists,Track A Finalists,7
Semifinalists,Track B Finalists,4
Semifinalists,Did Not Qualify,24
Track A Finalists,Finished,5
Track A Finalists,Did Not Finish,2
Track B Finalists,Finished,1
Track B Finalists,Did Not Finish,3
```

Qualifying teams were sorted into two groups: Track A teams were granted $1 million each to fund their competition entry; while Track B teams were invited to compete without any direct funding support from DARPA. 

Of the 35 semifinalist teams, 11 advanced to the final event -- with 7 from Track A and 4 from Track B. It's not a surprise that of the 6 teams that finished the race, 5 were Track A. Just one team from Track B, the Ben Franklin Racing Team[^2], managed against all odds to finish the race. How did they do it?

| Place | Team Name                              | Robot Name  | Team Size | Tech Stack                | Funding |
|-------|----------------------------------------|:-----------:|:---------:|:-------------------------:|--------:|
| `#1`  | **Tartan Racing** [CMU1][CMU2][CMU3]   | Boss        | 50        | !!500 KLOC; C++!!         | $1M     |
| `#2`  | **Stanford Racing** [STAN1][STAN2]     | Junior      | 44        | 600 KLOC; C++             | $1M     |
| `#3`  | **VictorTango** [VT1][VT2][VT3]        | Odin        | 50        | ?                         | $1M     |
| `#4`  | **Team MIT** [MIT1][MIT2]              | Talos       | 41        | 140 KLOC; C, Java, Python | $1M     |
| `#5`  | **Ben Franklin Racing** [BFRT1][BFRT2] | Little Ben  | 20        | !!5KLOC; MATLAB!!         | $250K   |
| `#6`  | **Cornell** [CU1][CU2]                 | Skynet      | 20        | ? KLOC; C++               | $1M     |

When you look at the table above it's clear that despite their small size and limited funding, BFRT had a significant competitive advantage; whereas other teams invested in a C++ codebase that comprised hundreds of thousands of lines of code, Little Ben ran on just 5,000 lines of MATLAB code -- two orders of magnitude fewer lines of code than any other team.

This is a striking result, and it serves to challenge some conventional wisdom in robotic system design; high-level languages like MATLAB, which are sometimes considered "scripting languages", are often dismissed as being too slow or limited for serious applications. But in this case, BFRT was able to leverage MATLAB's extensive toolboxes and high-level abstractions to rapidly prototype, simulate, and deploy their autonomous driving logic.

**This is where Mech comes in.** Because the truth is, despite it working out for the BFRT, MATLAB still has a lot of shortcomings -- critically that it's not free and open source, so it can never really be a viable option for most developers. Therefore, Mech is our attempt to build an open-source language in this space that combines the best features of MATLAB with the performance and flexibility of a systems programming language like C++ in the context of robot programming. 

Mech includes all of the matrix operations, data manipulation, and high-level abstractions that make MATLAB so powerful, but it also provides features such as: 

- blazing fast performance
- more data types and structures
- static typing, including physical units
- state machines
- capability permission system
- reactive programming model 
- concurrent and distrubted runtime
- live programming environment
- advanced debugging modalities, like time travel debugging

which make it more suitable for building complex, distributed systems from prototype to production. 

So why Mech? If you're looking to build a complex system, something on the order of a robot car, Mech will allow you to implement it in fewer lines of code, with performance on par with systems langauges, but safety and flexibility that you would expect from a high-level language.
