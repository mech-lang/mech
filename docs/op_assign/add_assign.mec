math/add_assign
===============================================================================

%% In-place addition: `+=` (scalar, vector, and ranged row-updates)

1. Usage
-------------------------------------------------------------------------------

```mech:disabled

X += Y


X[I] += Y


A[I, :] += Y
```

2. Description
-------------------------------------------------------------------------------

Performs **in-place addition** on the left-hand side (the *sink*), adding
the right-hand side (the *source*) elementwise and storing the result back
into the sink. Ranged forms support updating a 1D slice of a vector or a set
of **rows** in a 2D matrix (all columns).

3. Input
-------------------------------------------------------------------------------

| Argument | Kind                                     | Description |
|----------|------------------------------------------|-------------|
| `X`      | scalar, vector, or matrix (sink)         | The lvalue being updated. |
| `Y`      | scalar, vector, or matrix (source)       | Values to add. Must be broadcastable/matching shape depending on the form (see below). |
| `I`      | `[usize]` or `[bool]`                    | Indices (1-based) or a boolean mask selecting elements or rows to update. |

**Supported element types (sink & source):** unsigned integers `u8,u16,u32,u64,u128`, signed integers `i8,i16,i32,i64`, floating-point `f32,f64`, and extended types `rational`, `complex`.

4. Output
-------------------------------------------------------------------------------

| Result | Kind      | Description |
|--------|-----------|-------------|
| `X`    | matches X | The same object as the sink, updated in place. |

5. Examples  
-------------------------------------------------------------------------------

(a) Scalar-to-scalar

```mech:ex1
x := 10
x += 3               # x = 13
```

(b) Vector += scalar

```mech:ex2
v := [1, 2, 3, 4]
v += 10              # v = [11, 12, 13, 14]
```

(c) Vector += vector (elementwise)

```mech:ex3
a := [1, 2, 3]
b := [10, 20, 30]
a += b              
```

(d) 1D ranged update by **indices** (1-based)

```mech:ex4
v := [0, 0, 0, 0, 0]
I := [2, 4, 5]       # 1-based indices
v[I] += 1           
```

(e) 1D ranged update by **boolean mask**

```mech:ex5
v := [0, 0, 0, 0]
mask := [false, true, false, true]
v[mask] += 7         
```

(f) 1D ranged update with **vector** source

```mech:ex6
v := [1, 1, 1, 1]
I := [1, 3]
src := [5, 9]
v[I] += src        
```

(g) 2D row update (all columns), scalar source

```mech:ex7
A := [1, 2; 3, 4; 5, 6]   
rows := [1, 3]            
A[rows, :] += 10
# A = [11, 12; 3, 4; 15, 16]
```

(h) 2D row update with **row-aligned matrix** source

```mech:ex8
A := [1, 2, 3; 4, 5, 6]       
rows := [2]                   
S := [10, 20, 30]             
A[rows, :] += S
# A = [1, 2, 3; 14, 25, 36]
```

(i) 2D row update by **boolean mask**

```mech:ex9
A := [0, 0; 0, 0; 0, 0]   
mask := [true, false, true]
A[mask, :] += 5
# A = [5, 5; 0, 0; 5, 5]
```

6. Details
-------------------------------------------------------------------------------

- **Operation:** For matching shapes, updates are elementwise: $$ X \mathrel{+}= Y \quad\Rightarrow\quad X_i \leftarrow X_i + Y_i. $$ Scalar sources broadcast over the selected elements/rows.

- **Indexing semantics:** 1D ranged updates with explicit indices are **1-based** (e.g., `I = [1,3]` selects positions 1 and 3). Boolean masks must have the same length as the target 1D vector or number of rows for a 2D matrix.

- **2D ranged form:** `A[I, :] += Y` selects **rows** by `I` and updates **all columns**.   `Y` can be a scalar (broadcast to each selected row and column) or a matrix whose number of rows equals `len(I)` and whose number of columns equals `A.ncols()`.

- **Type support:** Unsigned/signed integers, `f32`, `f64`, and extended `rational` and `complex` numbers are supported. Mixed-type addition follows the underlying engine's coercion rules; when in doubt, cast beforehand.

- **In-place behavior:** The sink is modified directly and returned as the result.

7. Notes for Implementers
-------------------------------------------------------------------------------

Backed by the `AddAssignMath`, `AddAssignRange`, and `AddAssignRangeAll` paths.  
1D ranged updates support index lists and boolean masks. 2D ranged updates apply
to row selections with all columns. Indices are 1-based in the explicit-index path.
Element loops perform straightforward in-place updates.

8. See also
-------------------------------------------------------------------------------

`math/sub_assign` (`-=`), `math/mul_assign` (`*=`), `math/div_assign` (`/=`)
