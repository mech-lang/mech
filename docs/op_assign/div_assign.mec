math/div_assign
===============================================================================

%% In-place division: `/=` (scalar, vector, and ranged row-updates)

1. Usage
-------------------------------------------------------------------------------

```mech:disabled
X /= Y

X[I] /= Y

A[I, :] /= Y
```

2. Description
-------------------------------------------------------------------------------

Performs **in-place division** on the left-hand side (the *sink*), dividing by
the right-hand side (the *source*) elementwise and storing the result back
into the sink. Ranged forms support updating a 1D slice of a vector or a set
of **rows** in a 2D matrix (all columns).

3. Input
-------------------------------------------------------------------------------

| Argument | Kind                                     | Description |
|----------|------------------------------------------|-------------|
| `X`      | scalar, vector, or matrix (sink)         | The lvalue being updated. |
| `Y`      | scalar, vector, or matrix (source)       | Divisors. Must be broadcastable/matching shape depending on the form (see below). |
| `I`      | `[usize]` or `[bool]`                    | Indices (1-based) or a boolean mask selecting elements or rows to update. |

**Supported element types (sink & source):** unsigned integers `u8,u16,u32,u64,u128`, signed integers `i8,i16,i32,i64`, floating-point `f32,f64`, and extended types `rational`, `complex`.

4. Output
-------------------------------------------------------------------------------

| Result | Kind      | Description |
|--------|-----------|-------------|
| `X`    | matches X | The same object as the sink, updated in place. |

5. Examples  
-------------------------------------------------------------------------------

(a) Scalar-to-scalar

```mech:ex1
x := 20
x /= 4               
```

(b) Vector /= scalar

```mech:ex2
v := [10, 20, 30, 40]
v /= 10             
```

(c) Vector /= vector (elementwise)

```mech:ex3
a := [10, 20, 30]
b := [2, 5, 3]
a /= b               
```

(d) 1D ranged update by **indices** (1-based)

```mech:ex4
v := [10, 10, 10, 10, 10]
I := [2, 4, 5]
v[I] /= 5           
```

(e) 1D ranged update by **boolean mask**

```mech:ex5
v := [9, 9, 9, 9]
mask := [false, true, false, true]
v[mask] /= 3         
```

(f) 1D ranged update with **vector** source

```mech:ex6
v := [10, 10, 10, 10]
I := [1, 3]
src := [2, 5]
v[I] /= src         
```

(g) 2D row update (all columns), scalar source

```mech:ex7
A := [2, 4; 6, 8; 10, 12]  
rows := [1, 3]             
A[rows, :] /= 2
# A = [1, 2; 6, 8; 5, 6]
```

(h) 2D row update with **row-aligned matrix** source

```mech:ex8
A := [10, 20, 30; 40, 50, 60]   
rows := [2]                    
S := [2, 5, 3]                  
A[rows, :] /= S
# A = [10, 20, 30; 20, 10, 20]
```

(i) 2D row update by **boolean mask**

```mech:ex9
A := [9, 9; 9, 9; 9, 9]     
mask := [true, false, true]
A[mask, :] /= 3
# A = [3, 3; 9, 9; 3, 3]
```

6. Details
-------------------------------------------------------------------------------

- **Operation:** For matching shapes, updates are elementwise: $$ X \mathrel{/}= Y \quad\Rightarrow\quad X_i \leftarrow X_i / Y_i. $$ Scalar sources broadcast over the selected elements/rows.

- **Indexing semantics:** 1D ranged updates with explicit indices are **1-based** (e.g., `I = [1,3]` selects positions 1 and 3). Boolean masks must have the same length as the target 1D vector or number of rows for a 2D matrix.

- **2D ranged form:** `A[I, :] /= Y` selects **rows** by `I` and updates **all columns**. `Y` can be a scalar (broadcast to each selected row and column) or a matrix whose number of rows equals `len(I)` and whose number of columns equals `A.ncols()`.

- **Type behavior & edge cases:**
  - **Division by zero:** For integer sinks, this is typically an error; for floats, results may be `±∞` or `NaN` depending on the source value.
  - **Integer division:** Follows Rust semantics—division truncates toward zero and stays in the integer domain. Cast to `f32`/`f64` if you need fractional results.
  - **Complex/rational:** Uses the engine’s exact arithmetic for rationals and standard complex division for complex numbers.
  - **NaN/Inf propagation (floats):** Behaves per IEEE-754/libm.

- **In-place behavior:** The sink is modified directly and returned as the result.

7. Notes for Implementers
-------------------------------------------------------------------------------

Backed by the `DivAssignValue`, `DivAssignRange`, and `DivAssignRangeAll` paths.  
1D ranged updates support index lists and boolean masks. 2D ranged updates apply
to row selections with all columns. Indices are 1-based in the explicit-index path.
Tight loops perform the in-place updates; scalar sources are dereferenced and
broadcast across selected elements.

8. See also
-------------------------------------------------------------------------------

`math/mul_assign` (`*=`), `math/add_assign` (`+=`), `math/sub_assign` (`-=`)
