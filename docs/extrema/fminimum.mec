math/fminimum
===============================================================================

%% Elementwise minimum, IEEE-754 minimum semantics (NaN-propagating)

1. Usage
-------------------------------------------------------------------------------

```mech:disabled
Z := math/fminimum(X, Y)
```

2. Description
-------------------------------------------------------------------------------

Returns the elementwise minimum of `X` and `Y` using IEEE-754 **minimum**
semantics. Unlike `minimumNumber`, this variant **propagates NaNs**: if either
argument is `NaN`, the result is `NaN`. The result `Z` has the same shape and
type as the inputs.

3. Input
-------------------------------------------------------------------------------

| Argument | Kind                               | Description |
|----------|------------------------------------|-------------|
| `X`      | `float`, `[float]`, `matrix`       | First input. Common cases are `f64`, `f32`, and their vector/matrix forms. |
| `Y`      | `float`, `[float]`, `matrix`       | Second input. Must match the shape and type of `X`. |

4. Output
-------------------------------------------------------------------------------

| Argument | Kind             | Description |
|----------|------------------|-------------|
| `Z`      | matches input    | Elementwise minimum of `X` and `Y`. Shape and type match `X`/`Y`. |

5. Examples  
-------------------------------------------------------------------------------

(a) Minimum of two numbers

```mech:ex1
z := math/fminimum(2.5, 7.0)        
```

(b) Elementwise minimum for vectors

```mech:ex2
x := [1.0, 5.0, -3.0]
y := [4.0, 2.0, -7.0]
z := math/fminimum(x, y)             
```

(c) Elementwise minimum for a matrix

```mech:ex3
a := [1.0, -2.0; 3.5, 0.0]
b := [0.5, -3.0; 2.0, 4.0]
z := math/fminimum(a, b)            
```

(d) Behavior with NaN (NaN-propagating)

```mech:ex4
x := [NaN,  2.0, NaN]
y := [1.0, NaN, 3.0]
z := math/fminimum(x, y)             
```

6. Details
-------------------------------------------------------------------------------

- **Semantics:** Uses IEEE-754 **minimum** (NaN-propagating). If either operand is `NaN`, the result is `NaN`. This differs from `math/fminimum_num`, which returns the non-`NaN` operand when exactly one is `NaN`.

- **Shapes:** `X` and `Y` must have identical shapes. Scalars with scalars, vectors with vectors, and matrices with matrices (same dimensions). The result `Z` matches the input shape.

- **Types:** Backed by platform implementations of `fminimum` (f64) and `fminimumf` (f32). Vector and matrix forms apply the same operation elementwise. Mixed-precision inputs are not allowed; cast beforehand if needed.

- **Signed zeros & ties:** Per IEEE-754 and typical libm behavior, `math/fminimum(+0.0, -0.0)` yields `-0.0`. If values compare equal, the chosen operand follows IEEE rules and underlying implementation details.

- **Performance:** Vector and matrix forms loop over elements in place. For large arrays, prefer matching contiguous memory layouts to maximize locality.

7. Notes for Implementers
-------------------------------------------------------------------------------

This operation corresponds to the Rust/libm functions `fminimum` (f64) and
`fminimumf` (f32). In this codebase, dispatch is generated across scalar, vector,
and matrix types; each variant performs the same elementwise minimum and returns
an output of the same shape and type.

