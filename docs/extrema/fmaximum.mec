math/fmaximum
===============================================================================

%% Elementwise maximum, IEEE-754 maximum semantics (NaN-propagating)

1. Usage
-------------------------------------------------------------------------------

```mech:disabled
Z := math/fmaximum(X, Y)
```

2. Description
-------------------------------------------------------------------------------

Returns the elementwise maximum of `X` and `Y` using IEEE-754 **maximum**
semantics. Unlike `maximumNumber`, this variant **propagates NaNs**: if either
argument is `NaN`, the result is `NaN`. The result `Z` has the same shape and
type as the inputs.

3. Input
-------------------------------------------------------------------------------

| Argument | Kind                               | Description |
|----------|------------------------------------|-------------|
| `X`      | `float`, `[float]`, `matrix`       | First input. Common cases are `f64`, `f32`, and their vector/matrix forms. |
| `Y`      | `float`, `[float]`, `matrix`       | Second input. Must match the shape and type of `X`. |

4. Output
-------------------------------------------------------------------------------

| Argument | Kind             | Description |
|----------|------------------|-------------|
| `Z`      | matches input    | Elementwise maximum of `X` and `Y`. Shape and type match `X`/`Y`. |

5. Examples  
-------------------------------------------------------------------------------

(a) Maximum of two numbers

```mech:ex1
z := math/fmaximum(2.5, 7.0)        
```

(b) Elementwise maximum for vectors

```mech:ex2
x := [1.0, 5.0, -3.0]
y := [4.0, 2.0, -7.0]
z := math/fmaximum(x, y)            
```

(c) Elementwise maximum for a matrix

```mech:ex3
a := [1.0, -2.0; 3.5, 0.0]
b := [0.5, -3.0; 2.0, 4.0]
z := math/fmaximum(a, b)             
```

(d) Behavior with NaN (NaN-propagating)

```mech:ex4
x := [NaN,  2.0, NaN]
y := [1.0, NaN, 3.0]
z := math/fmaximum(x, y)            
```

6. Details
-------------------------------------------------------------------------------

- **Semantics:** Uses IEEE-754 **maximum** (NaN-propagating). If either operand
  is `NaN`, the result is `NaN`. This differs from `math/fmaximum_num`, which
  returns the non-`NaN` operand when exactly one is `NaN`.

- **Shapes:** `X` and `Y` must have identical shapes. Scalars with scalars,
  vectors with vectors, and matrices with matrices (same dimensions). The
  result `Z` matches the input shape.

- **Types:** Backed by platform implementations of `fmaximum` (f64) and
  `fmaximumf` (f32). Vector and matrix forms apply the same operation elementwise.
  Mixed-precision inputs are not allowed; cast beforehand if needed.

- **Signed zeros & ties:** Comparison follows IEEE-754. When comparing `+0.0`
  and `-0.0`, the sign of zero in the result follows the underlying libm's
  IEEE behavior (commonly `+0.0`). If values compare equal, the chosen operand
  is implementation-defined within IEEE rules.

- **Performance:** Vector and matrix forms loop over elements in place. For
  large arrays, prefer matching contiguous memory layouts to maximize locality.

7. Notes for Implementers
-------------------------------------------------------------------------------

This operation corresponds to the Rust/libm functions `fmaximum` (f64) and
`fmaximumf` (f32). In this codebase, dispatch is generated across scalar, vector,
and matrix types; each variant performs the same elementwise maximum and returns
an output of the same shape and type.

