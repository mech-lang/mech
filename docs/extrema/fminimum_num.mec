math/fminimum_num
===============================================================================

%% Elementwise minimum, IEEE-754 minimumNumber semantics

1. Usage
-------------------------------------------------------------------------------

```mech:disabled
Z := math/fminimum_num(X, Y)
```

2. Description
-------------------------------------------------------------------------------

Returns the elementwise minimum of `X` and `Y`. The result `Z` has the same
shape as the inputs. This function follows IEEE-754 *minimumNumber* semantics:
if exactly one argument is `NaN`, the other argument is returned; if both are
`NaN`, the result is `NaN`.

3. Input
-------------------------------------------------------------------------------

| Argument | Kind                               | Description |
|----------|------------------------------------|-------------|
| `X`      | `float`, `[float]`, `matrix`       | First input. Accepts real numeric types supported by the runtime; common cases are `f64`, `f32`, and their vector/matrix forms. |
| `Y`      | `float`, `[float]`, `matrix`       | Second input. Must match the shape and type of `X`. |

4. Output
-------------------------------------------------------------------------------

| Argument | Kind             | Description |
|----------|------------------|-------------|
| `Z`      | matches input    | Elementwise minimum of `X` and `Y`. Shape and type match `X`/`Y`. |

5. Examples  
-------------------------------------------------------------------------------

(a) Minimum of two numbers

```mech:ex1
z := math/fminimum_num(2.5, 7.0)    
```

(b) Elementwise minimum for vectors

```mech:ex2
x := [1.0, 5.0, -3.0]
y := [4.0, 2.0, -7.0]
z := math/fminimum_num(x, y)         
```

(c) Elementwise minimum for a matrix

```mech:ex3
a := [1.0, -2.0; 3.5, 0.0]
b := [0.5, -3.0; 2.0, 4.0]
z := math/fminimum_num(a, b)         
```

(d) Behavior with NaN (minimumNumber semantics)

```mech:ex4
x := [NaN,  2.0, NaN]
y := [1.0, NaN, NaN]
z := math/fminimum_num(x, y)        
```

6. Details
-------------------------------------------------------------------------------

- **Semantics:** Uses IEEE-754 *minimumNumber*. Unlike a NaN-propagating min, this treats `NaN` specially: if exactly one operand is `NaN`, the other is chosen if both are `NaN`, the result is `NaN`. This avoids `NaN` contagion when only one side is invalid.

- **Shapes:** `X` and `Y` must have identical shapes. Scalars with scalars, vectors with vectors, and matrices with matrices (same dimensions). The result `Z` matches the input shape.

- **Types:** Backed by platform implementations of `fminimum_num` (f64) and `fminimum_numf` (f32). Vector and matrix forms apply the same operation elementwise. Mixed-precision inputs are not allowed; cast beforehand if needed.

- **Signed zeros & ties:** Per IEEE-754 and typical libm behavior, `math/fminimum_num(+0.0, -0.0)` yields `-0.0`. If values compare equal, the chosen operand follows IEEE rules and underlying implementation details.

- **Performance:** Vector and matrix forms loop over elements in place. For large arrays, prefer matching contiguous memory layouts to maximize locality.

7. Notes for Implementers
-------------------------------------------------------------------------------

This operation corresponds to the Rust/libm functions `fminimum_num` (f64) and
`fminimum_numf` (f32). In this codebase, dispatch is generated across scalar,
vector, and matrix types; each variant performs the same elementwise minimum and
returns an output of the same shape and type.

