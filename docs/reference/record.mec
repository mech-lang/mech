record
===============================================================================

%% A record is a collection of named fields, where each field has a name and a kind. Records group heterogeneous values into a single structured value, similar to a row in a table or a struct in other languages.

1. Syntax
-------------------------------------------------------------------------------

Records are written using curly braces `{}` with named fields. Each field is written as `name: value` and fields are separated by commas.

```
{ x: 1, y: true }
{ name: "Alice", age: 42, active: true }
```

When parsed and rendered, this code will appear as:

```mech:disabled
{ x: 1, y: true }
{ name: "Alice", age: 42, active: true }
```

Records may be written inline or across multiple lines for readability:

```
{
  x: 1.2,
  y: true,
  label: "pt1"
}
```

2. Kind
-------------------------------------------------------------------------------

In general, a record has the kind:

```mech:disabled
<{field1<kind1>, field2<kind2>,...}>
```

The kind of a record is determined by the names and kinds of its fields. The kind of a filed is inferred from its value, but can also be specified explicitly. For example, the following record has two fields, `x` of kind `f64` and `y` of kind `bool`. Therefore the kind is `{x<f64> y<bool>}`.

```mech:ex 2.1
{ x: 1, y: true }
```

The kind of a field can be specified with a type annotation:

```mech:ex 2.2
{ x<u8>: 1, y<bool>: true }
```

Custom record kinds can be defined:

```mech:ex 2.3
<point3> := <{x<f64> y<f64> z<f64>}>
p<point3> := { x: 1.0, y: 2.0, z: 3.0 }
```

3. Construction
-------------------------------------------------------------------------------

There are three ways to create a record:

- Record literals
- Selecting a row from a table

(3.1) Record Literals

Record literals are written using curly braces `{}` with named fields. Each field is written as `name: value` and fields are separated by commas.

```mech:ex 3.1
r := { x: 3, y: false }
```

Field kinds can be specified explicitly:

```mech:ex 3.1.1
r := { x<u8>: 3, y: false }   -- x is explicitly typed as `u8`, y is inferred as `bool`
```

(3.2) Nested Records

Records can be nested:

```mech:ex 3.2
r := { pos: { x: 1, y: 2 }, label: "A" }    -- record with nested record field
```

Nested records can also be written across multiple lines for readability:

```
r := {
  pos: {
    x: 1
    y: 2
  }
  label: "A"
}
```

(3.3) From Tables

Selecting a single row from a table produces a record whose fields correspond to the table columns.

```mech:ex 3.3
T := | x<f64>  y<bool> |
     |  1.2     true   |
     |  1.3     false  |

r := T{1}   -- r is a record `{x&lt;f64&gt;,y&lt;bool&gt;}`
```

4. Accessing Fields
-------------------------------------------------------------------------------

Fields are accessed using dot indexing `.`.

(4.1) Dot Indexing

```mech:ex 4.1
r := { x: 1.2, y: true }
r.x
```
Likewise, `y` can be accessed to return a `bool` value:

```mech:ex 4.1
r.y
```

(4.2) Nested Records

By chaining dot indexing, nested fields can be accessed:

```mech:ex 4.2
r := { pos: { x: 1, y: 2 }, label: "A" }
r.pos.x
```

5. Assigning Fields
-------------------------------------------------------------------------------

Records are immutable values. You cannot assign to an individual field in-place.

Instead, create a new record by constructing one explicitly:

```
r := { x: 1, y: 2 }
r2 := { x: r.x, y: 3 }
```

When records originate from tables, updates are performed at the table level, not on the record value itself.

6. Records and Tables
-------------------------------------------------------------------------------

Tables are conceptually *sets of records*. Each row in a table corresponds to one record with the same field names as the table columns.

```
T := | x<u8> y<bool> |
     |  1    true   |
     |  2    false  |

T{1} : <{x<u8> y<bool>}>
```

Selecting multiple rows produces a table, not a set of records:

```
T{1..=2}   -- returns a table
```

7. Records in Expressions
-------------------------------------------------------------------------------

Records can be used inside expressions, passed to functions, and constructed within comprehensions.

```
{ x: i, y: i*i } | i <- 1..=5
```

This produces a set of records, each with fields `x` and `y`.

8. Heterogeneous Fields
-------------------------------------------------------------------------------

Records naturally support heterogeneous data, since each field has its own kind.

```
r := { id: 1u64, name: "Bob", data: [1 2 3] }
```

Optional fields may be expressed using option kinds:

```
r := { x: 1?, y: _ }
```

9. Equality
-------------------------------------------------------------------------------

Two records are equal if all corresponding fields are equal.

```
{ x: 1, y: 2 } == { y: 2, x: 1 }  -- true
```

Record equality is field-based and order-independent.
