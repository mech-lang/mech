set
================================================================================

%% A set is an unordered collection of unique values. Sets are useful for representing groups of items where duplicates are not allowed, and for performing mathematical set operations like union, intersection, and difference.

1. Syntax
-------------------------------------------------------------------------------

A set is declared using curly braces `{}`.

Elements are separated by commas `,`. Duplicate elements are automatically removed.

```
{}                 -- An empty set
{1, 2, 3}          -- A set of numbers
{"a", "b", "c"}    -- A set of strings
{1, 1, 2, 3}       -- Duplicates are removed
```

When parsed and rendered, this code will appear as:

{}                 -- An empty set
{1, 2, 3}          -- A set of numbers
{"a", "b", "c"}    -- A set of strings
{1, 1, 2, 3}       -- Duplicates are removed

Sets are unordered. The order in which elements appear does not affect equality or behavior.

2. Kind
---------------------------------------------------------------------------

In general, a set has the kind:

```mech:disabled
<{T}:N>
```

Where `T` is the kind of the elements, and `N` is the number of elements. The number of elements can be omitted to compare sets of different sizes, but strictly speaking, two sets of different sizes have different kinds.

For example:

```mech:ex 2.1
A := {1, 2, 3}       -- kind: {<{f64}:3>}
B := {4, 5}          -- kind: {<{f64}:2>}
```

Other examples include:

```mech:ex 2.2
{1, 2, 3}         -- kind: {<{f64}:3>}
{"a", "b"}        -- kind: {<{string}:2>}
{(1, 2), (3, 4)}  -- kind: {<{(f64,f64)}:2>}
```

3. Constructing
---------------------------------------------------------------------------

There are three two to create sets:

- Set literals
    - {{A := {1, 2, 3}}}
- Set Comprehensions
    - {{B := {x * x | x <- 1..=5}}}

(3.1) Set Literals

An empty set is written as `{}`, and has kind `{<{_}>}`:

```mech:ex 3.1.1
{}
```

Non-empty sets are written with elements inside the braces, separated by commas:

```mech:ex 3.1.2
{1, 2, 3}
```

(3.2) Set Comprehensions

Sets can be constructed using *set comprehensions*, which generate elements based on patterns and predicates.

Comprehensions may contain:

- One or more generators (`<-`)
- Boolean conditions
- Let bindings
- Arbitrary expressions for the yielded element

For example, the following comprehension generates the set of friends-of-friends for a given user, excluding those with an ID of 9 or higher:

```mech:ex 3.2
pairs := {(1, 2), (1, 3), (2, 8), (3, 5), (3, 9)}
user := 1
{fof | (u, f) <- pairs, (f, fof) <- pairs, u == user, fof < 9}
```

For more, see [`set/comprehensions`](/stdlib/set/comprehensions.html)

4. Accessing Elements
-------------------------------------------------------------------------------

Sets do **not** support positional indexing, since they are unordered.

Instead, elements are accessed through:

- Membership tests
- Set operations
- Iteration (via comprehensions)

(4.1) Membership

Use `∈` to test membership:

```mech:ex 4.1
A := {1, 2, 3}
2 ∈ A
```

For more, see [`set/element-of`](/stdlib/set/element-of.html)

```mech:ex 4.1
4 ∈ A
```

Use `∉` for non-membership:

```mech:ex 4.1
4 ∉ A
```

For more, see [`set/not-element-of`](/stdlib/set/not-element-of.html)

5. Assigning Elements
--------------------------------------------------------------------------------

Sets are immutable values. You cannot assign into a set by index.

Instead, new sets are created using set operations.

```mech:ex 5.1
A := {1, 2, 3}
A2 := A ∪ {4}     -- Creates a new set
```

6. Operations
---------------------------------------------------------------------------

Mech supports standard mathematical set operations.

(6.1) Union

The union of two sets contains all elements that appear in either set.

```mech:ex 6.1
A := {1, 2, 3}
B := {2, 3, 4}
A ∪ B
```

For more, see [`set/union`](/stdlib/set/union.html)

(6.2) Intersection

The intersection contains elements common to both sets.

```mech:ex 6.2
A := {1, 2, 3}
B := {2, 3, 4}
A ∩ B
```

For more, see [`set/intersection`](/stdlib/set/intersection.html)

(6.3) Difference

The difference `A ∖ B` contains elements in `A` that are not in `B`.

```mech:ex 6.3
A := {"a", "b", "c"}
B := {"b", "c", "d"}
A ∖ B
```

For more, see [`set/difference`](/stdlib/set/difference.html)

(6.4) Subset and Superset

The subset operator `⊆` tests if all elements of one set are contained in another:

```mech:ex 6.4
A := {"b", "c"}
B := {"b", "c", "d"}
A ⊆ B
```

For more, see [`set/subset`](/stdlib/set/subset.html)

Similarly, the superset operator `⊇` tests if a set contains all elements of another:

```mech:ex 6.4
B ⊇ A
```

For more, see [`set/superset`](/stdlib/set/superset.html)

(6.5) Strict Subset and Superset

```mech:ex 6.5
A := {1, 2}
B := {1, 2, 3}
A ⊂ B
```

For more, see [`set/strict-subset`](/stdlib/set/strict-subset.html)

Likewise, the strict superset operator `⊃` tests if a set strictly contains another:

```mech:ex 6.5
B ⊃ A
```
For more, see [`set/strict-superset`](/stdlib/set/strict-superset.html)

If the sets are equal, strict relations are false:

```mech:ex 6.6
A := {1, 2}
B := {1, 2}
A ⊊ B
```
Also:

```mech:ex 6.6
A ⊋ B
```